<<<<<<< HEAD
<!DOCTYPE html>
<!--
  Particle Network Background – full-screen interactive particle network
  Uses: Three.js only (no Vanta – custom impl for full mouse attract/repel control)
  Integration: Add <div id="bg"></div> in your page; script mounts canvas inside it.
  To use on body: change container to document.body and adjust z-index.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Network Background</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        /* Full-screen container – canvas fills this, sits behind content */
        #bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        #bg canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="bg"></div>

    <!-- Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.min.js"></script>

    <script>
        (function() {
            'use strict';

            // =============================================================================
            // CONFIGURATION – edit these to customize appearance and behavior
            // =============================================================================

            var CONFIG = {
                // ----- Colors – yellow/gold theme (like Stigma Studios style) -----
                backgroundColor: 0x0f0d0a,        // Dark warm tint (not pitch black)
                particleColor: 0xffcc24,          // Gold – main particle color
                particleColor2: 0xffdd44,         // Lighter gold – accent
                lineColor: 0xffaa00,              // Amber for connecting lines
                particleColorWhite: 0xfff0c0,     // Warm white accent

                // ----- Particle count -----
                // Desktop: 200–400. Mobile: 80–150. Higher = denser, slower.
                particleCount: 280,
                particleCountMobile: 120,

                // ----- Connection lines -----
                connectRadius: 120,               // Max distance to draw line between particles (px)
                maxConnections: 800,              // Cap total lines per frame (performance)
                lineOpacity: 0.25,                // 0–1, line transparency

                // ----- Movement -----
                floatSpeed: 0.3,                  // Base floating speed (0.1–1)
                floatAmount: 1.2,                 // How far particles drift (pixels)

                // ----- Mouse / touch interaction -----
                // 'attract' = particles move TOWARD cursor
                // 'repel'   = particles move AWAY from cursor
                mouseMode: 'repel',

                mouseRadius: 180,                 // Distance of mouse influence (px)
                mouseStrength: 0.8,               // How strongly particles react (0.1–2)
                mouseEase: 0.08,                  // Smoothing for mouse movement (0.02–0.15)

                // ----- Glow / blur -----
                particleSize: 2.2,                // Particle dot size (px)
                particleGlow: true,               // Add soft glow around particles

                // ----- Performance -----
                reduceMotion: false               // Set true to disable animation if prefers-reduced-motion
            };

            // =============================================================================
            // Particle Network Implementation
            // =============================================================================

            var scene, camera, renderer, particles, geometry, material, lineMaterial;
            var particlePositions, particleVelocities, particleColors;
            var lineSegments = [];
            var mouse = { x: 0, y: 0, targetX: 0, targetY: 0 };
            var W, H;
            var animationId;

            function init() {
                var container = document.getElementById('bg');
                if (!container) return;

                W = window.innerWidth;
                H = window.innerHeight;

                var isMobile = W < 768;
                var count = isMobile ? CONFIG.particleCountMobile : CONFIG.particleCount;

                // Respect prefers-reduced-motion
                if (CONFIG.reduceMotion || window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    CONFIG.floatSpeed = 0;
                    CONFIG.floatAmount = 0;
                    CONFIG.mouseStrength = 0;
                }

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(CONFIG.backgroundColor);

                // Orthographic camera (2D-like, no perspective)
                camera = new THREE.OrthographicCamera(-W / 2, W / 2, H / 2, -H / 2, -1000, 1000);
                camera.position.z = 500;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(W, H);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(renderer.domElement);

                // Particle positions and velocities (arrays for CPU updates)
                particlePositions = new Float32Array(count * 3);
                particleVelocities = new Float32Array(count * 3);
                particleColors = new Float32Array(count * 3);

                var colors = [
                    [CONFIG.particleColor >> 16 & 255, CONFIG.particleColor >> 8 & 255, CONFIG.particleColor & 255],
                    [CONFIG.particleColor2 >> 16 & 255, CONFIG.particleColor2 >> 8 & 255, CONFIG.particleColor2 & 255],
                    [255, 240, 192]  // Warm white accent
                ];

                for (var i = 0; i < count; i++) {
                    particlePositions[i * 3]     = (Math.random() - 0.5) * W * 1.2;
                    particlePositions[i * 3 + 1] = (Math.random() - 0.5) * H * 1.2;
                    particlePositions[i * 3 + 2] = 0;

                    particleVelocities[i * 3]     = (Math.random() - 0.5) * 0.5;
                    particleVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                    particleVelocities[i * 3 + 2] = 0;

                    var c = colors[i % 3];
                    particleColors[i * 3]     = c[0] / 255;
                    particleColors[i * 3 + 1] = c[1] / 255;
                    particleColors[i * 3 + 2] = c[2] / 255;
                }

                // Particle points geometry
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

                var pointMaterialOptions = {
                    size: CONFIG.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    sizeAttenuation: true
                };

                if (CONFIG.particleGlow) {
                    // Larger, faint layer for glow (shares geometry so it stays in sync)
                    var glowMat = new THREE.PointsMaterial(Object.assign({}, pointMaterialOptions, {
                        size: CONFIG.particleSize * 2.5,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    }));
                    scene.add(new THREE.Points(geometry, glowMat));
                }

                material = new THREE.PointsMaterial(Object.assign(pointMaterialOptions, {
                    blending: CONFIG.particleGlow ? THREE.AdditiveBlending : THREE.NormalBlending,
                    depthWrite: false
                }));
                particles = new THREE.Points(geometry, material);
                scene.add(particles);

                // Lines (dynamically updated)
                lineMaterial = new THREE.LineBasicMaterial({
                    color: CONFIG.lineColor,
                    transparent: true,
                    opacity: CONFIG.lineOpacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                // Mouse / touch listeners
                function updateMouse(e) {
                    var x = (e.clientX !== undefined ? e.clientX : e.touches[0].clientX) - W / 2;
                    var y = -(e.clientY !== undefined ? e.clientY : e.touches[0].clientY) + H / 2;
                    mouse.targetX = x;
                    mouse.targetY = y;
                }

                window.addEventListener('mousemove', updateMouse);
                window.addEventListener('touchmove', function(e) { e.preventDefault(); updateMouse(e); }, { passive: false });

                window.addEventListener('resize', onResize);

                animate();
            }

            function onResize() {
                W = window.innerWidth;
                H = window.innerHeight;
                camera.left = -W / 2;
                camera.right = W / 2;
                camera.top = H / 2;
                camera.bottom = -H / 2;
                camera.updateProjectionMatrix();
                renderer.setSize(W, H);
            }

            function animate() {
                animationId = requestAnimationFrame(animate);

                var count = particlePositions.length / 3;
                var t = performance.now() * 0.001;

                // Smooth mouse
                mouse.x += (mouse.targetX - mouse.x) * CONFIG.mouseEase;
                mouse.y += (mouse.targetY - mouse.y) * CONFIG.mouseEase;

                // Update particles
                for (var i = 0; i < count; i++) {
                    var ix = i * 3;
                    var x = particlePositions[ix];
                    var y = particlePositions[ix + 1];

                    // Gentle floating (sin/cos for organic movement)
                    var fx = Math.sin(t * 0.7 + i * 0.1) * CONFIG.floatAmount * CONFIG.floatSpeed;
                    var fy = Math.cos(t * 0.5 + i * 0.07) * CONFIG.floatAmount * CONFIG.floatSpeed;

                    // Mouse influence
                    var dx = mouse.x - x;
                    var dy = mouse.y - y;
                    var dist = Math.sqrt(dx * dx + dy * dy) || 0.001;

                    if (dist < CONFIG.mouseRadius) {
                        var force = (1 - dist / CONFIG.mouseRadius) * CONFIG.mouseStrength;
                        if (CONFIG.mouseMode === 'repel') {
                            particleVelocities[ix]     -= (dx / dist) * force;
                            particleVelocities[ix + 1] -= (dy / dist) * force;
                        } else {
                            particleVelocities[ix]     += (dx / dist) * force;
                            particleVelocities[ix + 1] += (dy / dist) * force;
                        }
                    }

                    particleVelocities[ix]     += fx;
                    particleVelocities[ix + 1] += fy;

                    // Damping
                    particleVelocities[ix]     *= 0.98;
                    particleVelocities[ix + 1] *= 0.98;

                    particlePositions[ix]     += particleVelocities[ix];
                    particlePositions[ix + 1] += particleVelocities[ix + 1];

                    // Wrap edges
                    var margin = 80;
                    if (particlePositions[ix] < -W / 2 - margin) particlePositions[ix] = W / 2 + margin;
                    if (particlePositions[ix] > W / 2 + margin)  particlePositions[ix] = -W / 2 - margin;
                    if (particlePositions[ix + 1] < -H / 2 - margin) particlePositions[ix + 1] = H / 2 + margin;
                    if (particlePositions[ix + 1] > H / 2 + margin)  particlePositions[ix + 1] = -H / 2 - margin;
                }

                geometry.attributes.position.needsUpdate = true;

                // Update connections
                removeOldLines();
                drawConnections();

                renderer.render(scene, camera);
            }

            function removeOldLines() {
                for (var i = 0; i < lineSegments.length; i++) {
                    scene.remove(lineSegments[i]);
                    lineSegments[i].geometry.dispose();
                    lineSegments[i].material.dispose();
                }
                lineSegments.length = 0;
            }

            function drawConnections() {
                var count = particlePositions.length / 3;
                var r2 = CONFIG.connectRadius * CONFIG.connectRadius;
                var maxLines = CONFIG.maxConnections || 9999;
                var drawn = 0;

                for (var i = 0; i < count && drawn < maxLines; i++) {
                    for (var j = i + 1; j < count && drawn < maxLines; j++) {
                        var dx = particlePositions[j * 3]     - particlePositions[i * 3];
                        var dy = particlePositions[j * 3 + 1] - particlePositions[i * 3 + 1];
                        var d2 = dx * dx + dy * dy;
                        if (d2 < r2) {
                            var geom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(particlePositions[i * 3], particlePositions[i * 3 + 1], 0),
                                new THREE.Vector3(particlePositions[j * 3], particlePositions[j * 3 + 1], 0)
                            ]);
                            var line = new THREE.Line(geom, lineMaterial.clone());
                            line.material.opacity = CONFIG.lineOpacity * (1 - Math.sqrt(d2) / CONFIG.connectRadius);
                            scene.add(line);
                            lineSegments.push(line);
                            drawn++;
                        }
                    }
                }
            }

            // Start
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }

            // Expose config for runtime tweaking (e.g. in console: ParticleBg.CONFIG.mouseMode = 'attract')
            window.ParticleBg = { CONFIG: CONFIG };
        })();
    </script>
</body>
</html>
=======
<!DOCTYPE html>
<!--
  Particle Network Background – full-screen interactive particle network
  Uses: Three.js only (no Vanta – custom impl for full mouse attract/repel control)
  Integration: Add <div id="bg"></div> in your page; script mounts canvas inside it.
  To use on body: change container to document.body and adjust z-index.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Network Background</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        /* Full-screen container – canvas fills this, sits behind content */
        #bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        #bg canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="bg"></div>

    <!-- Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.min.js"></script>

    <script>
        (function() {
            'use strict';

            // =============================================================================
            // CONFIGURATION – edit these to customize appearance and behavior
            // =============================================================================

            var CONFIG = {
                // ----- Colors – yellow/gold theme (like Stigma Studios style) -----
                backgroundColor: 0x0f0d0a,        // Dark warm tint (not pitch black)
                particleColor: 0xffcc24,          // Gold – main particle color
                particleColor2: 0xffdd44,         // Lighter gold – accent
                lineColor: 0xffaa00,              // Amber for connecting lines
                particleColorWhite: 0xfff0c0,     // Warm white accent

                // ----- Particle count -----
                // Desktop: 200–400. Mobile: 80–150. Higher = denser, slower.
                particleCount: 280,
                particleCountMobile: 120,

                // ----- Connection lines -----
                connectRadius: 120,               // Max distance to draw line between particles (px)
                maxConnections: 800,              // Cap total lines per frame (performance)
                lineOpacity: 0.25,                // 0–1, line transparency

                // ----- Movement -----
                floatSpeed: 0.3,                  // Base floating speed (0.1–1)
                floatAmount: 1.2,                 // How far particles drift (pixels)

                // ----- Mouse / touch interaction -----
                // 'attract' = particles move TOWARD cursor
                // 'repel'   = particles move AWAY from cursor
                mouseMode: 'repel',

                mouseRadius: 180,                 // Distance of mouse influence (px)
                mouseStrength: 0.8,               // How strongly particles react (0.1–2)
                mouseEase: 0.08,                  // Smoothing for mouse movement (0.02–0.15)

                // ----- Glow / blur -----
                particleSize: 2.2,                // Particle dot size (px)
                particleGlow: true,               // Add soft glow around particles

                // ----- Performance -----
                reduceMotion: false               // Set true to disable animation if prefers-reduced-motion
            };

            // =============================================================================
            // Particle Network Implementation
            // =============================================================================

            var scene, camera, renderer, particles, geometry, material, lineMaterial;
            var particlePositions, particleVelocities, particleColors;
            var lineSegments = [];
            var mouse = { x: 0, y: 0, targetX: 0, targetY: 0 };
            var W, H;
            var animationId;

            function init() {
                var container = document.getElementById('bg');
                if (!container) return;

                W = window.innerWidth;
                H = window.innerHeight;

                var isMobile = W < 768;
                var count = isMobile ? CONFIG.particleCountMobile : CONFIG.particleCount;

                // Respect prefers-reduced-motion
                if (CONFIG.reduceMotion || window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    CONFIG.floatSpeed = 0;
                    CONFIG.floatAmount = 0;
                    CONFIG.mouseStrength = 0;
                }

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(CONFIG.backgroundColor);

                // Orthographic camera (2D-like, no perspective)
                camera = new THREE.OrthographicCamera(-W / 2, W / 2, H / 2, -H / 2, -1000, 1000);
                camera.position.z = 500;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(W, H);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(renderer.domElement);

                // Particle positions and velocities (arrays for CPU updates)
                particlePositions = new Float32Array(count * 3);
                particleVelocities = new Float32Array(count * 3);
                particleColors = new Float32Array(count * 3);

                var colors = [
                    [CONFIG.particleColor >> 16 & 255, CONFIG.particleColor >> 8 & 255, CONFIG.particleColor & 255],
                    [CONFIG.particleColor2 >> 16 & 255, CONFIG.particleColor2 >> 8 & 255, CONFIG.particleColor2 & 255],
                    [255, 240, 192]  // Warm white accent
                ];

                for (var i = 0; i < count; i++) {
                    particlePositions[i * 3]     = (Math.random() - 0.5) * W * 1.2;
                    particlePositions[i * 3 + 1] = (Math.random() - 0.5) * H * 1.2;
                    particlePositions[i * 3 + 2] = 0;

                    particleVelocities[i * 3]     = (Math.random() - 0.5) * 0.5;
                    particleVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                    particleVelocities[i * 3 + 2] = 0;

                    var c = colors[i % 3];
                    particleColors[i * 3]     = c[0] / 255;
                    particleColors[i * 3 + 1] = c[1] / 255;
                    particleColors[i * 3 + 2] = c[2] / 255;
                }

                // Particle points geometry
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

                var pointMaterialOptions = {
                    size: CONFIG.particleSize,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    sizeAttenuation: true
                };

                if (CONFIG.particleGlow) {
                    // Larger, faint layer for glow (shares geometry so it stays in sync)
                    var glowMat = new THREE.PointsMaterial(Object.assign({}, pointMaterialOptions, {
                        size: CONFIG.particleSize * 2.5,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    }));
                    scene.add(new THREE.Points(geometry, glowMat));
                }

                material = new THREE.PointsMaterial(Object.assign(pointMaterialOptions, {
                    blending: CONFIG.particleGlow ? THREE.AdditiveBlending : THREE.NormalBlending,
                    depthWrite: false
                }));
                particles = new THREE.Points(geometry, material);
                scene.add(particles);

                // Lines (dynamically updated)
                lineMaterial = new THREE.LineBasicMaterial({
                    color: CONFIG.lineColor,
                    transparent: true,
                    opacity: CONFIG.lineOpacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                // Mouse / touch listeners
                function updateMouse(e) {
                    var x = (e.clientX !== undefined ? e.clientX : e.touches[0].clientX) - W / 2;
                    var y = -(e.clientY !== undefined ? e.clientY : e.touches[0].clientY) + H / 2;
                    mouse.targetX = x;
                    mouse.targetY = y;
                }

                window.addEventListener('mousemove', updateMouse);
                window.addEventListener('touchmove', function(e) { e.preventDefault(); updateMouse(e); }, { passive: false });

                window.addEventListener('resize', onResize);

                animate();
            }

            function onResize() {
                W = window.innerWidth;
                H = window.innerHeight;
                camera.left = -W / 2;
                camera.right = W / 2;
                camera.top = H / 2;
                camera.bottom = -H / 2;
                camera.updateProjectionMatrix();
                renderer.setSize(W, H);
            }

            function animate() {
                animationId = requestAnimationFrame(animate);

                var count = particlePositions.length / 3;
                var t = performance.now() * 0.001;

                // Smooth mouse
                mouse.x += (mouse.targetX - mouse.x) * CONFIG.mouseEase;
                mouse.y += (mouse.targetY - mouse.y) * CONFIG.mouseEase;

                // Update particles
                for (var i = 0; i < count; i++) {
                    var ix = i * 3;
                    var x = particlePositions[ix];
                    var y = particlePositions[ix + 1];

                    // Gentle floating (sin/cos for organic movement)
                    var fx = Math.sin(t * 0.7 + i * 0.1) * CONFIG.floatAmount * CONFIG.floatSpeed;
                    var fy = Math.cos(t * 0.5 + i * 0.07) * CONFIG.floatAmount * CONFIG.floatSpeed;

                    // Mouse influence
                    var dx = mouse.x - x;
                    var dy = mouse.y - y;
                    var dist = Math.sqrt(dx * dx + dy * dy) || 0.001;

                    if (dist < CONFIG.mouseRadius) {
                        var force = (1 - dist / CONFIG.mouseRadius) * CONFIG.mouseStrength;
                        if (CONFIG.mouseMode === 'repel') {
                            particleVelocities[ix]     -= (dx / dist) * force;
                            particleVelocities[ix + 1] -= (dy / dist) * force;
                        } else {
                            particleVelocities[ix]     += (dx / dist) * force;
                            particleVelocities[ix + 1] += (dy / dist) * force;
                        }
                    }

                    particleVelocities[ix]     += fx;
                    particleVelocities[ix + 1] += fy;

                    // Damping
                    particleVelocities[ix]     *= 0.98;
                    particleVelocities[ix + 1] *= 0.98;

                    particlePositions[ix]     += particleVelocities[ix];
                    particlePositions[ix + 1] += particleVelocities[ix + 1];

                    // Wrap edges
                    var margin = 80;
                    if (particlePositions[ix] < -W / 2 - margin) particlePositions[ix] = W / 2 + margin;
                    if (particlePositions[ix] > W / 2 + margin)  particlePositions[ix] = -W / 2 - margin;
                    if (particlePositions[ix + 1] < -H / 2 - margin) particlePositions[ix + 1] = H / 2 + margin;
                    if (particlePositions[ix + 1] > H / 2 + margin)  particlePositions[ix + 1] = -H / 2 - margin;
                }

                geometry.attributes.position.needsUpdate = true;

                // Update connections
                removeOldLines();
                drawConnections();

                renderer.render(scene, camera);
            }

            function removeOldLines() {
                for (var i = 0; i < lineSegments.length; i++) {
                    scene.remove(lineSegments[i]);
                    lineSegments[i].geometry.dispose();
                    lineSegments[i].material.dispose();
                }
                lineSegments.length = 0;
            }

            function drawConnections() {
                var count = particlePositions.length / 3;
                var r2 = CONFIG.connectRadius * CONFIG.connectRadius;
                var maxLines = CONFIG.maxConnections || 9999;
                var drawn = 0;

                for (var i = 0; i < count && drawn < maxLines; i++) {
                    for (var j = i + 1; j < count && drawn < maxLines; j++) {
                        var dx = particlePositions[j * 3]     - particlePositions[i * 3];
                        var dy = particlePositions[j * 3 + 1] - particlePositions[i * 3 + 1];
                        var d2 = dx * dx + dy * dy;
                        if (d2 < r2) {
                            var geom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(particlePositions[i * 3], particlePositions[i * 3 + 1], 0),
                                new THREE.Vector3(particlePositions[j * 3], particlePositions[j * 3 + 1], 0)
                            ]);
                            var line = new THREE.Line(geom, lineMaterial.clone());
                            line.material.opacity = CONFIG.lineOpacity * (1 - Math.sqrt(d2) / CONFIG.connectRadius);
                            scene.add(line);
                            lineSegments.push(line);
                            drawn++;
                        }
                    }
                }
            }

            // Start
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }

            // Expose config for runtime tweaking (e.g. in console: ParticleBg.CONFIG.mouseMode = 'attract')
            window.ParticleBg = { CONFIG: CONFIG };
        })();
    </script>
</body>
</html>
>>>>>>> 746ca995f3eda8c3fd89fb23f33fa0cf112a2b06
